#!/usr/bin/env node

/**
 * Build script that minifies HTML/CSS/JS and generates C++ header files
 * Uses Vite and html-minifier-terser for minification
 */

import { readFile, writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { minify as minifyHTML } from 'html-minifier-terser';
import { minify as minifyCSS } from 'csso';
import { minify as minifyJS } from 'terser';
import chokidar from 'chokidar';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');

// Configuration
const config = {
  htmlSourceDir: join(projectRoot, 'html_source'),
  jsSourceDir: join(projectRoot, 'js_source'),
  htmlOutputDir: join(projectRoot, 'html'),
  jsOutputDir: join(projectRoot, 'js'),
  minify: true,
};

// Minification options
const minifyOptions = {
  html: {
    collapseWhitespace: true,
    removeComments: true,
    minifyCSS: true,
    minifyJS: true,
    removeAttributeQuotes: false,
    caseSensitive: true,
    conservativeCollapse: false,
  },
  css: {
    restructure: false, // Keep structure for readability if needed
  },
  js: {
    compress: {
      drop_console: false, // Keep console for debugging
      drop_debugger: true,
    },
    format: {
      comments: false,
    },
  },
};

/**
 * Escape a string for use in a C string literal
 */
function escapeCString(content) {
  return content
    .replace(/\\/g, '\\\\')  // Escape backslashes first
    .replace(/"/g, '\\"')     // Escape quotes
    .replace(/\n/g, '\\n')    // Escape newlines
    .replace(/\t/g, '\\t')    // Escape tabs
    .replace(/\r/g, '\\r');   // Escape carriage returns
}

/**
 * Generate a header file from source content
 */
async function generateHeader(sourcePath, outputPath, macroName, content) {
  const sourceFileName = sourcePath.split(/[/\\]/).pop();
  const guardName = macroName.toUpperCase().replace(/[^A-Z0-9_]/g, '_') + '_H';
  
  const headerContent = `#ifndef ${guardName}
#define ${guardName}

// Auto-generated from ${sourceFileName}
// DO NOT EDIT THIS FILE DIRECTLY - Edit ${sourcePath.replace(projectRoot + '/', '')} instead
// Run 'npm run build' or 'yarn build' to regenerate

#define ${macroName} \\
"${escapeCString(content)}"

#endif // ${guardName}
`;

  // Ensure output directory exists
  const outputDir = dirname(outputPath);
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  await writeFile(outputPath, headerContent, 'utf-8');
  console.log(`âœ“ Generated ${outputPath.replace(projectRoot + '/', '')}`);
}

/**
 * Process a CSS file
 */
async function processCSS(sourcePath, outputPath, macroName) {
  let content = await readFile(sourcePath, 'utf-8');
  
  if (config.minify) {
    try {
      const result = await minifyCSS(content, minifyOptions.css);
      content = result.css;
    } catch (error) {
      console.warn(`Warning: Could not minify CSS ${sourcePath}:`, error.message);
    }
  }
  
  await generateHeader(sourcePath, outputPath, macroName, content);
}

/**
 * Process an HTML file
 */
async function processHTML(sourcePath, outputPath, macroName) {
  let content = await readFile(sourcePath, 'utf-8');
  
  if (config.minify) {
    try {
      content = await minifyHTML(content, minifyOptions.html);
    } catch (error) {
      console.warn(`Warning: Could not minify HTML ${sourcePath}:`, error.message);
    }
  }
  
  await generateHeader(sourcePath, outputPath, macroName, content);
}

/**
 * Process a JavaScript file
 */
async function processJS(sourcePath, outputPath, macroName) {
  let content = await readFile(sourcePath, 'utf-8');
  
  if (config.minify) {
    try {
      const result = await minifyJS(content, minifyOptions.js);
      content = result.code;
    } catch (error) {
      console.warn(`Warning: Could not minify JS ${sourcePath}:`, error.message);
    }
  }
  
  await generateHeader(sourcePath, outputPath, macroName, content);
}

/**
 * Process all files
 */
async function buildAll() {
  console.log('Building HTML/JS headers...\n');
  
  const fileMappings = [
    // CSS files
    {
      source: join(config.htmlSourceDir, 'common_styles.css'),
      output: join(config.htmlOutputDir, 'common_styles.h'),
      macro: 'HTML_COMMON_STYLES',
      processor: processCSS,
    },
    {
      source: join(config.htmlSourceDir, 'game_selection_styles.css'),
      output: join(config.htmlOutputDir, 'game_selection_styles.h'),
      macro: 'HTML_GAME_SELECTION_STYLES',
      processor: processCSS,
    },
    {
      source: join(config.htmlSourceDir, 'board_view_styles.css'),
      output: join(config.htmlOutputDir, 'board_view_styles.h'),
      macro: 'HTML_BOARD_VIEW_STYLES',
      processor: processCSS,
    },
    {
      source: join(config.htmlSourceDir, 'board_edit_styles.css'),
      output: join(config.htmlOutputDir, 'board_edit_styles.h'),
      macro: 'HTML_BOARD_EDIT_STYLES',
      processor: processCSS,
    },
    // HTML files
    {
      source: join(config.htmlSourceDir, 'game_selection.html'),
      output: join(config.htmlOutputDir, 'game_selection.html.h'),
      macro: 'HTML_GAME_SELECTION_CONTENT',
      processor: processHTML,
    },
    {
      source: join(config.htmlSourceDir, 'evaluation_bar.html'),
      output: join(config.htmlOutputDir, 'evaluation_bar.html.h'),
      macro: 'HTML_EVALUATION_BAR',
      processor: processHTML,
    },
    {
      source: join(config.htmlSourceDir, 'board_view.html'),
      output: join(config.htmlOutputDir, 'board_view.html.h'),
      macro: 'HTML_BOARD_VIEW_CONTENT',
      processor: processHTML,
    },
    {
      source: join(config.htmlSourceDir, 'board_edit.html'),
      output: join(config.htmlOutputDir, 'board_edit.html.h'),
      macro: 'HTML_BOARD_EDIT_CONTENT',
      processor: processHTML,
    },
    // JavaScript files
    {
      source: join(config.htmlSourceDir, 'game_selection.js'),
      output: join(config.htmlOutputDir, 'game_selection_script.h'),
      macro: 'HTML_GAME_SELECTION_SCRIPT',
      processor: processJS,
    },
    {
      source: join(config.jsSourceDir, 'piece_symbols.js'),
      output: join(config.jsOutputDir, 'piece_symbols.js.h'),
      macro: 'JS_PIECE_SYMBOLS',
      processor: processJS,
    },
    {
      source: join(config.jsSourceDir, 'evaluation_bar.js'),
      output: join(config.jsOutputDir, 'evaluation_bar.js.h'),
      macro: 'JS_EVALUATION_UPDATE',
      processor: processJS,
    },
    {
      source: join(config.jsSourceDir, 'board_update.js'),
      output: join(config.jsOutputDir, 'board_update.js.h'),
      macro: 'JS_BOARD_UPDATE',
      processor: processJS,
    },
    {
      source: join(config.jsSourceDir, 'board_view.js'),
      output: join(config.jsOutputDir, 'board_view.js.h'),
      macro: 'JS_BOARD_VIEW',
      processor: processJS,
    },
    {
      source: join(config.jsSourceDir, 'board_edit.js'),
      output: join(config.jsOutputDir, 'board_edit.js.h'),
      macro: 'JS_BOARD_EDIT',
      processor: processJS,
    },
  ];

  let successCount = 0;
  let errorCount = 0;

  for (const mapping of fileMappings) {
    try {
      if (!existsSync(mapping.source)) {
        console.warn(`âš  Source file not found: ${mapping.source.replace(projectRoot + '/', '')}`);
        continue;
      }
      
      await mapping.processor(mapping.source, mapping.output, mapping.macro);
      successCount++;
    } catch (error) {
      console.error(`âœ— Error processing ${mapping.source}:`, error.message);
      errorCount++;
    }
  }

  console.log(`\nâœ“ Generated ${successCount} header files${errorCount > 0 ? ` (${errorCount} errors)` : ''}`);
  return errorCount === 0;
}

/**
 * Watch mode
 */
async function watch() {
  console.log('Watching for changes...\n');
  
  const watcher = chokidar.watch([
    join(config.htmlSourceDir, '**/*'),
    join(config.jsSourceDir, '**/*'),
  ], {
    ignored: /(^|[\/\\])\../, // ignore dotfiles
    persistent: true,
  });

  watcher.on('change', async (path) => {
    console.log(`\nðŸ“ File changed: ${path.replace(projectRoot + '/', '')}`);
    await buildAll();
  });

  // Initial build
  await buildAll();
}

// Main
const args = process.argv.slice(2);
const isWatch = args.includes('--watch') || args.includes('-w');

if (isWatch) {
  watch().catch(console.error);
} else {
  buildAll().then(success => {
    process.exit(success ? 0 : 1);
  }).catch(error => {
    console.error('Build failed:', error);
    process.exit(1);
  });
}

